//! Vulnerability scanning module
//! 
//! This module provides functions for scanning packages for known vulnerabilities
//! by integrating with security databases.

use anyhow::Result;
use serde::{Deserialize, Serialize};
use tracing::info;

/// Vulnerability severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

/// Vulnerability information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub title: String,
    pub description: String,
    pub severity: Severity,
    pub affected_versions: Vec<String>,
    pub patched_versions: Vec<String>,
    pub references: Vec<String>,
}

/// Vulnerability scan report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    pub package_name: String,
    pub package_version: String,
    pub vulnerabilities: Vec<Vulnerability>,
    pub scan_timestamp: chrono::DateTime<chrono::Utc>,
}

impl VulnerabilityReport {
    /// Create a new vulnerability report
    pub fn new(package_name: String, package_version: String) -> Self {
        Self {
            package_name,
            package_version,
            vulnerabilities: Vec::new(),
            scan_timestamp: chrono::Utc::now(),
        }
    }

    /// Add a vulnerability to the report
    pub fn add_vulnerability(&mut self, vulnerability: Vulnerability) {
        self.vulnerabilities.push(vulnerability);
    }

    /// Get the highest severity vulnerability in the report
    pub fn highest_severity(&self) -> Option<&Severity> {
        self.vulnerabilities
            .iter()
            .map(|v| &v.severity)
            .max()
    }

    /// Check if the report contains critical vulnerabilities
    pub fn has_critical_vulnerabilities(&self) -> bool {
        self.vulnerabilities
            .iter()
            .any(|v| v.severity == Severity::Critical)
    }
}

/// Scan a package for known vulnerabilities
/// 
/// # Arguments
/// * `package_name` - Name of the package to scan
/// * `package_version` - Version of the package to scan
/// 
/// # Returns
/// * `Ok(VulnerabilityReport)` with the scan results
/// * `Err(anyhow::Error)` if the scan fails
pub async fn scan_for_vulnerabilities(package_name: &str, package_version: &str) -> Result<VulnerabilityReport> {
    info!("Scanning package {}@{} for vulnerabilities", package_name, package_version);
    
    // In a real implementation, this would query security databases like:
    // - NVD (National Vulnerability Database)
    // - OSV (Open Source Vulnerabilities)
    // - Snyk
    // - GitHub Advisory Database
    
    // For now, we'll return an empty report
    let mut report = VulnerabilityReport::new(package_name.to_string(), package_version.to_string());
    
    // Simulate some vulnerabilities for testing
    if package_name == "test-package-with-vulns" {
        report.add_vulnerability(Vulnerability {
            id: "CVE-2023-0001".to_string(),
            title: "Prototype Pollution".to_string(),
            description: "The package is vulnerable to Prototype Pollution leading to Remote Code Execution.".to_string(),
            severity: Severity::High,
            affected_versions: vec!["< 1.2.3".to_string()],
            patched_versions: vec!["1.2.3".to_string()],
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2023-0001".to_string(),
                "https://github.com/advisories/GHSA-xxxx-xxxx-xxxx".to_string(),
            ],
        });
        
        report.add_vulnerability(Vulnerability {
            id: "CVE-2023-0002".to_string(),
            title: "Regular Expression Denial of Service (ReDoS)".to_string(),
            description: "The package is vulnerable to Regular Expression Denial of Service (ReDoS) via a regex in the parse function.".to_string(),
            severity: Severity::Medium,
            affected_versions: vec!["< 2.1.0".to_string()],
            patched_versions: vec!["2.1.0".to_string()],
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2023-0002".to_string(),
            ],
        });
    }
    
    Ok(report)
}

/// Check if a package version is affected by a specific vulnerability
/// 
/// # Arguments
/// * `package_version` - Version of the package to check
/// * `affected_versions` - List of version constraints that are affected
/// 
/// # Returns
/// * `true` if the package version is affected
/// * `false` otherwise
pub fn is_version_affected(package_version: &str, affected_versions: &[String]) -> bool {
    // In a real implementation, this would parse version constraints and check
    // if the package version matches any of them
    // For now, we'll just do a simple check
    affected_versions.iter().any(|constraint| {
        // Simple check for "< X.Y.Z" format
        if constraint.starts_with("< ") {
            let constraint_version = &constraint[2..];
            package_version < constraint_version
        } else {
            // For other formats, we'll just return false for now
            false
        }
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_scan_for_vulnerabilities_no_vulns() {
        let report = scan_for_vulnerabilities("safe-package", "1.0.0").await.unwrap();
        assert_eq!(report.vulnerabilities.len(), 0);
    }

    #[tokio::test]
    async fn test_scan_for_vulnerabilities_with_vulns() {
        let report = scan_for_vulnerabilities("test-package-with-vulns", "1.0.0").await.unwrap();
        assert_eq!(report.vulnerabilities.len(), 2);
        
        let highest_severity = report.highest_severity().unwrap();
        assert_eq!(*highest_severity, Severity::High);
        
        assert!(!report.has_critical_vulnerabilities());
    }

    #[test]
    fn test_is_version_affected() {
        assert!(is_version_affected("1.0.0", &vec!["< 1.2.3".to_string()]));
        assert!(!is_version_affected("1.5.0", &vec!["< 1.2.3".to_string()]));
        assert!(!is_version_affected("1.2.3", &vec!["< 1.2.3".to_string()]));
    }
}